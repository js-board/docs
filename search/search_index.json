{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>JS-Board is a Javascript firmware that runs on ESP32 microcontrollers to simplify the development and deployment of applications. It uses the Moddable SDK and facilitates configuring devices, uploading new applications as mods, and performing general troubleshooting. The primary interface for JS-Board is a web app served by the device itself over WiFi.</p> <p>The goal of JS-Board is to support the following use-cases:</p> <ul> <li>Develop applications on a WiFi-attached device without having to connect a USB cable.</li> <li>Interactively explore the device's capabilities and troubleshoot problems using a   web-based REPL (read-print-eval loop).</li> <li>Deploy new devices by flashing them with JS-Board from the web browser and then   upload your application.</li> <li>Manage deployed devices through their web interface.</li> </ul>"},{"location":"#license","title":"License","text":"<p>JS-Board uses the Apache 2.0 license, which means everything is free.</p>"},{"location":"known-issues/","title":"Known Issues","text":"<p>As of this writing, FlexDash is in alpha state. The general functioning of the dashboard itself (i.e. the code running in the browser) is fairly robust and has been used in several projects. However, the Node-RED integration and some of the ramifications are not polished. The main known issues are listed below.</p> <p>Warning</p> <p>One of the reasons FlexDash and its integration into Node-RED have an 'alpha' status is that the way certain things work may change, forcing users to rebuild their dashbaords.</p> <p>For example, very early on the FlexDash node names were changed to have an \"fd\" prefix, e.g., \"button\" became \"fd button\". At that time no-one was using FlexDash so it was an easy decision.</p>"},{"location":"known-issues/#big-picture-issues","title":"Big picture issues","text":"<p>Note: not all the changes described below will happen, this is more a list of what is being contemplated.</p> <ul> <li>There are more unknown issues than known issues \ud83d\ude09</li> <li>FlexDash uses the Vuetify set of UI components and more specifically, the Vuetify 3   beta version which still has a lot of quirks. (Edit: this is nearing resolution.)   Some of the positioning of elements   is messed-up, in particular overlays and pop-ups are problematic. Some desirable UI elements,   such as data tables, tree view, date picker, etc have not yet been ported from version 2.</li> <li>Support for subflows has hard limitations, such as only supporting one level of subflows, and   its implementation uses some dirty tricks due to limitations in Node-RED's flow editor.</li> <li>The Node-RED integration overall relies on a large set of assumptions about the (undocumented)   inner workings of Node-RED and the flow editor. This is bound to result in corner cases that do   not function well. Specific areas of concern are projects, disabled flows, and export/import of   flows.</li> <li>Editing a FlexDash node in the flow editor uses <code>typed input</code> input fields which have various   issues with defaults for boolean values, <code>null</code> as object or string values, not supporting   the input of multi-line strings, not supporting a color picker, and more. An input field better   suited for FlexDash is badly needed.</li> <li>There is no authentication for dashboard users in the Node-RED integration. FlexDash supports   very basic auth but the integration doesn't. This is a to-do item.</li> <li>While it is possible to develop new FlexDash widgets with instant \"hot module reload\" of   changes there is no support for quick dynamic widgets equivalent to the \"UI template\"   node in the \"old\" Node-RED dashboard. Support is planned (and was there with Vue 2) but   needs to be reimplemented.</li> <li>FlexDash does not deal with the browser's history. E.g., the back button does not work as   one would expect when switching between tabs and reloading the page switches to the initial   tab.</li> <li>Some of the internals of FlexDash may yet change to allow arbitrary nesting of containers,   e.g. panel in panel in grid in tab. This can be done without breaking existing dashboards   but it may introduce some instability and some minor breaking changes.</li> <li>There has been discussion about switching from having dozens of core nodes to having a   single generic \"FlexDash Widget\" node that has a \"widget type\" selector. In that case, the   current nodes can be maintained for a while giving time to migrate, but eventually this will   create some migration work for early adopters.</li> </ul>"},{"location":"known-issues/#minor-issues","title":"Minor issues","text":"<p>A list of issues is kept in the README of the node-red-flexdash repo.</p>"},{"location":"quick-start/","title":"JS-Board quick start","text":"<p>Seeing JS-Board in action takes only a couple of steps:</p> <ol> <li>Locate your favorite ESP32 device and connect it to your computer using a USB cable.</li> <li>Open a Chrome or Edge web browser on Linux/MacOS/Windows and navigate to    http://js-board.github.io/flash.</li> <li>Follow the instructions on the page to flash your device with JS-Board (this use WebSerial).</li> <li>Once the device is flashed, it will reboot and you can configure it in the web browser to    connect to your WiFi network.</li> <li>Once the device is connected to your WiFi network, you can click through to the device's    web interface and start exploring.</li> </ol>"},{"location":"quick-start/#esp32-device","title":"ESP32 device","text":"<p>Currently JS-Board is only compatible with \"standard\" ESP32 devices, i.e., no ESP32-C3, ESP32-S3, etc. Support for these will follow...</p>"},{"location":"quick-start/#browser","title":"Browser","text":"<p>The web flashing uses the WebSerial API, which is currently only supported by Chrome and Edge. Other browsers derived from Chrome (Brave, Vivaldi, et.al) should also work. Firefox will definitely not work (they pretty much refuse supporting any API that accesses local machine resources, oh well...) Open http://js-board.github.io/flash.</p>"},{"location":"quick-start/#flashing","title":"Flashing","text":"<p>The code on the web page uses the WebSerial API to let you choose the serial port to which your ESP32 is attached. It then erases the flash and proceeds to program the device with the JS-Board firmware. It uses the same protocol as the command-line esptool.py utility.</p> <p>If you are having difficulties with the web flashing, you can also install esptool.py. Under linux your package manager most likely has a package for it and that would be the recommended option. The alternative is to follow the directions on the esptool.py page to install it using pip.</p>"},{"location":"quick-start/#configuration","title":"Configuration","text":"<p>Once the device is flashed, it will connect to the web flasher and be ready for configuration asking you to connect it to your WiFi network. Once connected to wifi the web page will provide a link to the web interface where you can start managing the device and uploading your application.</p> <p>If you flashed the device using esptool.py you will need to connect to the device's WiFi access point (the SSID is of the form <code>JSB_XXXXXX</code>) and then navigate to <code>http://192.168.4.1/</code>. When you connect to the access point the device provides a captive portal which should cause your operating system to bring up a browser to authenticate with the network (this is designed for public access points where yuo have to agree to terms of service to get internet access). This browser is typically limited bu should work to get your device onto your local wifi.</p>"}]}